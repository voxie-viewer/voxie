// This file was automatically generated by tools/update-property-types.py
// All changes to this file will be lost

// This file will be included by Types.cpp

namespace {
class PropertyTypeBoolean : public PropertyType {
 public:
  PropertyTypeBoolean()
      : PropertyType("de.uni_stuttgart.Voxie.PropertyType.Boolean", "Boolean",
                     QVariant::fromValue<bool>(false)) {}
  ~PropertyTypeBoolean() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<bool>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<bool>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override { return qMetaTypeId<bool>(); }

  bool isComparable() override { return true; }
  int compare(
      /*const QSharedPointer<NodeProperty>& property,*/ const QVariant& v1,
      const QVariant& v2) override {
    if (v1.userType() != qMetaTypeId<bool>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<bool>()))
              .arg(QMetaType::typeName(v1.userType()))
              .arg(v1.userType()));
    if (v2.userType() != qMetaTypeId<bool>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<bool>()))
              .arg(QMetaType::typeName(v2.userType()))
              .arg(v2.userType()));
    return defaultValueCompare(  // property,
        vx::PropertyValueConvertRaw<bool, bool>::fromRaw(v1.value<bool>()),
        vx::PropertyValueConvertRaw<bool, bool>::fromRaw(v2.value<bool>()));
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new BooleanUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<bool>(ParseJsonFun<bool>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<bool>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<bool>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<bool>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<bool>();
    return dbusMakeVariant<bool>(
        PropertyValueConvertDBus<bool, bool>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<bool>(
        PropertyValueConvertDBus<bool, bool>::toRaw(
            dbusGetVariantValue<bool>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("b"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::BooleanType() {
  return vx::types::Boolean::type();
}
QSharedPointer<PropertyType> vx::types::Boolean::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeBoolean>();
  return type;
}

namespace {
class PropertyTypeBox3DAxisAligned : public PropertyType {
 public:
  PropertyTypeBox3DAxisAligned()
      : PropertyType(
            "de.uni_stuttgart.Voxie.PropertyType.Box3DAxisAligned",
            "Bounding box (3D)",
            QVariant::fromValue<std::tuple<std::tuple<double, double, double>,
                                           std::tuple<double, double, double>>>(
                std::make_tuple(vx::TupleVector<double, 3>(0, 0, 0),
                                vx::TupleVector<double, 3>(0, 0, 0)))) {}
  ~PropertyTypeBox3DAxisAligned() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() !=
        qMetaTypeId<std::tuple<std::tuple<double, double, double>,
                               std::tuple<double, double, double>>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<
                      std::tuple<std::tuple<double, double, double>,
                                 std::tuple<double, double, double>>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<std::tuple<std::tuple<double, double, double>,
                                  std::tuple<double, double, double>>>();
  }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new Box3DAxisAlignedUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<std::tuple<std::tuple<double, double, double>,
                                          std::tuple<double, double, double>>>(
        ParseJsonFun<
            std::tuple<std::tuple<double, double, double>,
                       std::tuple<double, double, double>>>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<std::tuple<std::tuple<double, double, double>,
                                        std::tuple<double, double, double>>>(
        value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() !=
        qMetaTypeId<std::tuple<std::tuple<double, double, double>,
                               std::tuple<double, double, double>>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<
                      std::tuple<std::tuple<double, double, double>,
                                 std::tuple<double, double, double>>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw =
        value.value<std::tuple<std::tuple<double, double, double>,
                               std::tuple<double, double, double>>>();
    return dbusMakeVariant<std::tuple<std::tuple<double, double, double>,
                                      std::tuple<double, double, double>>>(
        PropertyValueConvertDBus<
            std::tuple<std::tuple<double, double, double>,
                       std::tuple<double, double, double>>,
            std::tuple<std::tuple<double, double, double>,
                       std::tuple<double, double, double>>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<std::tuple<std::tuple<double, double, double>,
                                          std::tuple<double, double, double>>>(
        PropertyValueConvertDBus<
            std::tuple<std::tuple<double, double, double>,
                       std::tuple<double, double, double>>,
            std::tuple<std::tuple<double, double, double>,
                       std::tuple<double, double, double>>>::
            toRaw(dbusGetVariantValue<
                  std::tuple<std::tuple<double, double, double>,
                             std::tuple<double, double, double>>>(value)));
  }

  QDBusSignature dbusSignature() override {
    return QDBusSignature("((ddd)(ddd))");
  }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::Box3DAxisAlignedType() {
  return vx::types::Box3DAxisAligned::type();
}
QSharedPointer<PropertyType> vx::types::Box3DAxisAligned::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeBox3DAxisAligned>();
  return type;
}

namespace {
class PropertyTypeColor : public PropertyType {
 public:
  PropertyTypeColor()
      : PropertyType(
            "de.uni_stuttgart.Voxie.PropertyType.Color", "Color",
            QVariant::fromValue<std::tuple<double, double, double, double>>(
                vx::Color::black().asTuple())) {}
  ~PropertyTypeColor() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() !=
        qMetaTypeId<std::tuple<double, double, double, double>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<double, double, double, double>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<std::tuple<double, double, double, double>>();
  }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new ColorUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<std::tuple<double, double, double, double>>(
        ParseJsonFun<std::tuple<double, double, double, double>>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<std::tuple<double, double, double, double>>(value,
                                                                         this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() !=
        qMetaTypeId<std::tuple<double, double, double, double>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<double, double, double, double>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<std::tuple<double, double, double, double>>();
    return dbusMakeVariant<std::tuple<double, double, double, double>>(
        PropertyValueConvertDBus<
            std::tuple<double, double, double, double>,
            std::tuple<double, double, double, double>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<std::tuple<double, double, double, double>>(
        PropertyValueConvertDBus<std::tuple<double, double, double, double>,
                                 std::tuple<double, double, double, double>>::
            toRaw(
                dbusGetVariantValue<std::tuple<double, double, double, double>>(
                    value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("(dddd)"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::ColorType() {
  return vx::types::Color::type();
}
QSharedPointer<PropertyType> vx::types::Color::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeColor>();
  return type;
}

namespace {
class PropertyTypeDataType : public PropertyType {
 public:
  PropertyTypeDataType()
      : PropertyType(
            "de.uni_stuttgart.Voxie.PropertyType.DataType", "Data type",
            QVariant::fromValue<std::tuple<QString, quint32, QString>>(
                std::tuple<QString, quint32, QString>("float", 32, "native"))) {
  }
  ~PropertyTypeDataType() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() !=
        qMetaTypeId<std::tuple<QString, quint32, QString>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<QString, quint32, QString>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    verifyDataType(property,
                   value.value<std::tuple<QString, quint32, QString>>());
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<std::tuple<QString, quint32, QString>>();
  }

  bool isComparable() override { return true; }
  int compare(
      /*const QSharedPointer<NodeProperty>& property,*/ const QVariant& v1,
      const QVariant& v2) override {
    if (v1.userType() != qMetaTypeId<std::tuple<QString, quint32, QString>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<QString, quint32, QString>>()))
              .arg(QMetaType::typeName(v1.userType()))
              .arg(v1.userType()));
    if (v2.userType() != qMetaTypeId<std::tuple<QString, quint32, QString>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<QString, quint32, QString>>()))
              .arg(QMetaType::typeName(v2.userType()))
              .arg(v2.userType()));
    return defaultValueCompare(  // property,
        vx::PropertyValueConvertRaw<std::tuple<QString, quint32, QString>,
                                    vx::DataType>::
            fromRaw(v1.value<std::tuple<QString, quint32, QString>>()),
        vx::PropertyValueConvertRaw<std::tuple<QString, quint32, QString>,
                                    vx::DataType>::
            fromRaw(v2.value<std::tuple<QString, quint32, QString>>()));
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new DataTypeUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<std::tuple<QString, quint32, QString>>(
        ParseJsonFun<std::tuple<QString, quint32, QString>>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<std::tuple<QString, quint32, QString>>(value,
                                                                    this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() !=
        qMetaTypeId<std::tuple<QString, quint32, QString>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<QString, quint32, QString>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<std::tuple<QString, quint32, QString>>();
    return dbusMakeVariant<std::tuple<QString, quint32, QString>>(
        PropertyValueConvertDBus<
            std::tuple<QString, quint32, QString>,
            std::tuple<QString, quint32, QString>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<std::tuple<QString, quint32, QString>>(
        PropertyValueConvertDBus<std::tuple<QString, quint32, QString>,
                                 std::tuple<QString, quint32, QString>>::
            toRaw(dbusGetVariantValue<std::tuple<QString, quint32, QString>>(
                value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("(sus)"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::DataTypeType() {
  return vx::types::DataType::type();
}
QSharedPointer<PropertyType> vx::types::DataType::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeDataType>();
  return type;
}

namespace {
class PropertyTypeEnumeration : public PropertyType {
 public:
  PropertyTypeEnumeration()
      : PropertyType("de.uni_stuttgart.Voxie.PropertyType.Enumeration",
                     "Enumeration", QVariant::fromValue<QString>("")) {}
  ~PropertyTypeEnumeration() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<QString>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QString>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    verifyEnum(property, value.value<QString>());
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    return QVariant::fromValue<QString>(
        canonicalizeEnum(property, value.value<QString>()));
  }
  int getRawQMetaType() override { return qMetaTypeId<QString>(); }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new EnumerationUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<QString>(ParseJsonFun<QString>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<QString>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<QString>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QString>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<QString>();
    return dbusMakeVariant<QString>(
        PropertyValueConvertDBus<QString, QString>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<QString>(
        PropertyValueConvertDBus<QString, QString>::toRaw(
            dbusGetVariantValue<QString>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("s"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::EnumerationType() {
  return vx::types::Enumeration::type();
}
QSharedPointer<PropertyType> vx::types::Enumeration::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeEnumeration>();
  return type;
}

namespace {
class PropertyTypeFileName : public PropertyType {
 public:
  PropertyTypeFileName()
      : PropertyType("de.uni_stuttgart.Voxie.PropertyType.FileName",
                     "File Name", QVariant::fromValue<QString>("")) {}
  ~PropertyTypeFileName() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<QString>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QString>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override { return qMetaTypeId<QString>(); }

  bool isComparable() override { return true; }
  int compare(
      /*const QSharedPointer<NodeProperty>& property,*/ const QVariant& v1,
      const QVariant& v2) override {
    if (v1.userType() != qMetaTypeId<QString>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QString>()))
              .arg(QMetaType::typeName(v1.userType()))
              .arg(v1.userType()));
    if (v2.userType() != qMetaTypeId<QString>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QString>()))
              .arg(QMetaType::typeName(v2.userType()))
              .arg(v2.userType()));
    return defaultValueCompare(  // property,
        vx::PropertyValueConvertRaw<QString, QString>::fromRaw(
            v1.value<QString>()),
        vx::PropertyValueConvertRaw<QString, QString>::fromRaw(
            v2.value<QString>()));
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new FileNameUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<QString>(ParseJsonFun<QString>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<QString>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<QString>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QString>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<QString>();
    return dbusMakeVariant<QString>(
        PropertyValueConvertDBus<QString, QString>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<QString>(
        PropertyValueConvertDBus<QString, QString>::toRaw(
            dbusGetVariantValue<QString>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("s"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::FileNameType() {
  return vx::types::FileName::type();
}
QSharedPointer<PropertyType> vx::types::FileName::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeFileName>();
  return type;
}

namespace {
class PropertyTypeFloat : public PropertyType {
 public:
  PropertyTypeFloat()
      : PropertyType("de.uni_stuttgart.Voxie.PropertyType.Float",
                     "Floating pointer number",
                     QVariant::fromValue<double>(0.0)) {}
  ~PropertyTypeFloat() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<double>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<double>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override { return qMetaTypeId<double>(); }

  bool isComparable() override { return true; }
  int compare(
      /*const QSharedPointer<NodeProperty>& property,*/ const QVariant& v1,
      const QVariant& v2) override {
    if (v1.userType() != qMetaTypeId<double>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<double>()))
              .arg(QMetaType::typeName(v1.userType()))
              .arg(v1.userType()));
    if (v2.userType() != qMetaTypeId<double>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<double>()))
              .arg(QMetaType::typeName(v2.userType()))
              .arg(v2.userType()));
    return defaultValueCompare(  // property,
        vx::PropertyValueConvertRaw<double, double>::fromRaw(
            v1.value<double>()),
        vx::PropertyValueConvertRaw<double, double>::fromRaw(
            v2.value<double>()));
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new FloatUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<double>(ParseJsonFun<double>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<double>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<double>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<double>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<double>();
    return dbusMakeVariant<double>(
        PropertyValueConvertDBus<double, double>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<double>(
        PropertyValueConvertDBus<double, double>::toRaw(
            dbusGetVariantValue<double>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("d"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::FloatType() {
  return vx::types::Float::type();
}
QSharedPointer<PropertyType> vx::types::Float::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeFloat>();
  return type;
}

namespace {
class PropertyTypeGeometricPrimitive : public PropertyType {
 public:
  PropertyTypeGeometricPrimitive()
      : PropertyType("de.uni_stuttgart.Voxie.PropertyType.GeometricPrimitive",
                     "Geometric primitive", QVariant::fromValue<quint64>(0)) {}
  ~PropertyTypeGeometricPrimitive() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<quint64>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<quint64>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override { return qMetaTypeId<quint64>(); }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new GeometricPrimitiveUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<quint64>(ParseJsonFun<quint64>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<quint64>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<quint64>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<quint64>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<quint64>();
    return dbusMakeVariant<quint64>(
        PropertyValueConvertDBus<quint64, quint64>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<quint64>(
        PropertyValueConvertDBus<quint64, quint64>::toRaw(
            dbusGetVariantValue<quint64>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("t"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::GeometricPrimitiveType() {
  return vx::types::GeometricPrimitive::type();
}
QSharedPointer<PropertyType> vx::types::GeometricPrimitive::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeGeometricPrimitive>();
  return type;
}

namespace {
class PropertyTypeInt : public PropertyType {
 public:
  PropertyTypeInt()
      : PropertyType("de.uni_stuttgart.Voxie.PropertyType.Int",
                     "Integer number (64 bit, signed)",
                     QVariant::fromValue<qint64>(0)) {}
  ~PropertyTypeInt() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<qint64>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<qint64>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override { return qMetaTypeId<qint64>(); }

  bool isComparable() override { return true; }
  int compare(
      /*const QSharedPointer<NodeProperty>& property,*/ const QVariant& v1,
      const QVariant& v2) override {
    if (v1.userType() != qMetaTypeId<qint64>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<qint64>()))
              .arg(QMetaType::typeName(v1.userType()))
              .arg(v1.userType()));
    if (v2.userType() != qMetaTypeId<qint64>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<qint64>()))
              .arg(QMetaType::typeName(v2.userType()))
              .arg(v2.userType()));
    return defaultValueCompare(  // property,
        vx::PropertyValueConvertRaw<qint64, qint64>::fromRaw(
            v1.value<qint64>()),
        vx::PropertyValueConvertRaw<qint64, qint64>::fromRaw(
            v2.value<qint64>()));
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new IntUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<qint64>(ParseJsonFun<qint64>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<qint64>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<qint64>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<qint64>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<qint64>();
    return dbusMakeVariant<qint64>(
        PropertyValueConvertDBus<qint64, qint64>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<qint64>(
        PropertyValueConvertDBus<qint64, qint64>::toRaw(
            dbusGetVariantValue<qint64>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("x"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::IntType() {
  return vx::types::Int::type();
}
QSharedPointer<PropertyType> vx::types::Int::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeInt>();
  return type;
}

namespace {
class PropertyTypeIntList : public PropertyType {
 public:
  PropertyTypeIntList()
      : PropertyType("de.uni_stuttgart.Voxie.PropertyType.IntList", "Int List",
                     QVariant::fromValue<QList<qint64>>(QList<qint64>())) {}
  ~PropertyTypeIntList() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<QList<qint64>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QList<qint64>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override { return qMetaTypeId<QList<qint64>>(); }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new IntListUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<QList<qint64>>(
        parseNotSupported<QList<qint64>>(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<QList<qint64>>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<QList<qint64>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QList<qint64>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<QList<qint64>>();
    return dbusMakeVariant<QList<qint64>>(
        PropertyValueConvertDBus<QList<qint64>, QList<qint64>>::fromRaw(
            valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<QList<qint64>>(
        PropertyValueConvertDBus<QList<qint64>, QList<qint64>>::toRaw(
            dbusGetVariantValue<QList<qint64>>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("ax"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::IntListType() {
  return vx::types::IntList::type();
}
QSharedPointer<PropertyType> vx::types::IntList::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeIntList>();
  return type;
}

namespace {
class PropertyTypeLabelList : public PropertyType {
 public:
  PropertyTypeLabelList()
      : PropertyType("de.uni_stuttgart.Voxie.PropertyType.LabelList",
                     "Label List",
                     QVariant::fromValue<QList<quint64>>(QList<quint64>())) {}
  ~PropertyTypeLabelList() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<QList<quint64>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QList<quint64>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override { return qMetaTypeId<QList<quint64>>(); }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new LabelListUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<QList<quint64>>(
        parseNotSupported<QList<quint64>>(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<QList<quint64>>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<QList<quint64>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QList<quint64>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<QList<quint64>>();
    return dbusMakeVariant<QList<quint64>>(
        PropertyValueConvertDBus<QList<quint64>, QList<quint64>>::fromRaw(
            valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<QList<quint64>>(
        PropertyValueConvertDBus<QList<quint64>, QList<quint64>>::toRaw(
            dbusGetVariantValue<QList<quint64>>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("at"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::LabelListType() {
  return vx::types::LabelList::type();
}
QSharedPointer<PropertyType> vx::types::LabelList::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeLabelList>();
  return type;
}

namespace {
class PropertyTypeListPosition3D : public PropertyType {
 public:
  PropertyTypeListPosition3D()
      : PropertyType(
            "de.uni_stuttgart.Voxie.PropertyType.ListPosition3D",
            "Position3D List",
            QVariant::fromValue<QList<std::tuple<double, double, double>>>(
                QList<vx::TupleVector<double, 3>>())) {}
  ~PropertyTypeListPosition3D() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() !=
        qMetaTypeId<QList<std::tuple<double, double, double>>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<QList<std::tuple<double, double, double>>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<QList<std::tuple<double, double, double>>>();
  }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new ListPosition3DUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<QList<std::tuple<double, double, double>>>(
        parseNotSupported<QList<std::tuple<double, double, double>>>(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<QList<std::tuple<double, double, double>>>(value,
                                                                        this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() !=
        qMetaTypeId<QList<std::tuple<double, double, double>>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<QList<std::tuple<double, double, double>>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<QList<std::tuple<double, double, double>>>();
    return dbusMakeVariant<QList<std::tuple<double, double, double>>>(
        PropertyValueConvertDBus<
            QList<std::tuple<double, double, double>>,
            QList<std::tuple<double, double, double>>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<QList<std::tuple<double, double, double>>>(
        PropertyValueConvertDBus<QList<std::tuple<double, double, double>>,
                                 QList<std::tuple<double, double, double>>>::
            toRaw(
                dbusGetVariantValue<QList<std::tuple<double, double, double>>>(
                    value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("a(ddd)"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::ListPosition3DType() {
  return vx::types::ListPosition3D::type();
}
QSharedPointer<PropertyType> vx::types::ListPosition3D::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeListPosition3D>();
  return type;
}

namespace {
class PropertyTypeListPosition3DDoubleTuple : public PropertyType {
 public:
  PropertyTypeListPosition3DDoubleTuple()
      : PropertyType(
            "de.uni_stuttgart.Voxie.PropertyType.ListPosition3DDoubleTuple",
            "List with (3DPosition, double) tuples",
            QVariant::fromValue<
                QList<std::tuple<std::tuple<double, double, double>, double>>>(
                QList<std::tuple<vx::TupleVector<double, 3>, double>>())) {}
  ~PropertyTypeListPosition3DDoubleTuple() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() !=
        qMetaTypeId<
            QList<std::tuple<std::tuple<double, double, double>, double>>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<QList<std::tuple<
                      std::tuple<double, double, double>, double>>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<
        QList<std::tuple<std::tuple<double, double, double>, double>>>();
  }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new ListPosition3DDoubleTupleUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<
        QList<std::tuple<std::tuple<double, double, double>, double>>>(
        parseNotSupported<
            QList<std::tuple<std::tuple<double, double, double>, double>>>(
            value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<
        QList<std::tuple<std::tuple<double, double, double>, double>>>(value,
                                                                       this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() !=
        qMetaTypeId<
            QList<std::tuple<std::tuple<double, double, double>, double>>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<QList<std::tuple<
                      std::tuple<double, double, double>, double>>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<
        QList<std::tuple<std::tuple<double, double, double>, double>>>();
    return dbusMakeVariant<
        QList<std::tuple<std::tuple<double, double, double>, double>>>(
        PropertyValueConvertDBus<
            QList<std::tuple<std::tuple<double, double, double>, double>>,
            QList<std::tuple<std::tuple<double, double, double>, double>>>::
            fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<
        QList<std::tuple<std::tuple<double, double, double>, double>>>(
        PropertyValueConvertDBus<
            QList<std::tuple<std::tuple<double, double, double>, double>>,
            QList<std::tuple<std::tuple<double, double, double>, double>>>::
            toRaw(dbusGetVariantValue<QList<
                      std::tuple<std::tuple<double, double, double>, double>>>(
                value)));
  }

  QDBusSignature dbusSignature() override {
    return QDBusSignature("a((ddd)d)");
  }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::ListPosition3DDoubleTupleType() {
  return vx::types::ListPosition3DDoubleTuple::type();
}
QSharedPointer<PropertyType> vx::types::ListPosition3DDoubleTuple::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeListPosition3DDoubleTuple>();
  return type;
}

namespace {
class PropertyTypeNodeReference : public PropertyType {
 public:
  PropertyTypeNodeReference()
      : PropertyType(
            "de.uni_stuttgart.Voxie.PropertyType.NodeReference",
            "Node reference",
            QVariant::fromValue<QDBusObjectPath>(QDBusObjectPath("/"))) {}
  ~PropertyTypeNodeReference() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<QDBusObjectPath>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QDBusObjectPath>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override { return qMetaTypeId<QDBusObjectPath>(); }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new NodeReferenceUI(property, node);
  }

  QList<QString> compatibilityNames() override {
    return {
        "de.uni_stuttgart.Voxie.PropertyType.ObjectReference",
    };
  }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<QDBusObjectPath>(
        parseNotSupported<QDBusObjectPath>(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<QDBusObjectPath>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<QDBusObjectPath>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QDBusObjectPath>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<QDBusObjectPath>();
    return dbusMakeVariant<QDBusObjectPath>(
        PropertyValueConvertDBus<QDBusObjectPath, QDBusObjectPath>::fromRaw(
            valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<QDBusObjectPath>(
        PropertyValueConvertDBus<QDBusObjectPath, QDBusObjectPath>::toRaw(
            dbusGetVariantValue<QDBusObjectPath>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("o"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::NodeReferenceType() {
  return vx::types::NodeReference::type();
}
QSharedPointer<PropertyType> vx::types::NodeReference::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeNodeReference>();
  return type;
}

namespace {
class PropertyTypeNodeReferenceList : public PropertyType {
 public:
  PropertyTypeNodeReferenceList()
      : PropertyType("de.uni_stuttgart.Voxie.PropertyType.NodeReferenceList",
                     "Node reference list",
                     QVariant::fromValue<QList<QDBusObjectPath>>(
                         QList<QDBusObjectPath>())) {}
  ~PropertyTypeNodeReferenceList() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<QList<QDBusObjectPath>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QList<QDBusObjectPath>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<QList<QDBusObjectPath>>();
  }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new NodeReferenceListUI(property, node);
  }

  QList<QString> compatibilityNames() override {
    return {
        "de.uni_stuttgart.Voxie.PropertyType.ObjectReferenceList",
    };
  }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<QList<QDBusObjectPath>>(
        parseNotSupported<QList<QDBusObjectPath>>(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<QList<QDBusObjectPath>>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<QList<QDBusObjectPath>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QList<QDBusObjectPath>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<QList<QDBusObjectPath>>();
    return dbusMakeVariant<QList<QDBusObjectPath>>(
        PropertyValueConvertDBus<QList<QDBusObjectPath>,
                                 QList<QDBusObjectPath>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<QList<QDBusObjectPath>>(
        PropertyValueConvertDBus<QList<QDBusObjectPath>,
                                 QList<QDBusObjectPath>>::
            toRaw(dbusGetVariantValue<QList<QDBusObjectPath>>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("ao"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::NodeReferenceListType() {
  return vx::types::NodeReferenceList::type();
}
QSharedPointer<PropertyType> vx::types::NodeReferenceList::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeNodeReferenceList>();
  return type;
}

namespace {
class PropertyTypeOrientation3D : public PropertyType {
 public:
  PropertyTypeOrientation3D()
      : PropertyType(
            "de.uni_stuttgart.Voxie.PropertyType.Orientation3D",
            "Orientation (3D)",
            QVariant::fromValue<std::tuple<double, double, double, double>>(
                vx::TupleVector<double, 4>(1, 0, 0, 0))) {}
  ~PropertyTypeOrientation3D() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() !=
        qMetaTypeId<std::tuple<double, double, double, double>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<double, double, double, double>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<std::tuple<double, double, double, double>>();
  }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new Orientation3DUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<std::tuple<double, double, double, double>>(
        ParseJsonFun<std::tuple<double, double, double, double>>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<std::tuple<double, double, double, double>>(value,
                                                                         this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() !=
        qMetaTypeId<std::tuple<double, double, double, double>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<double, double, double, double>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<std::tuple<double, double, double, double>>();
    return dbusMakeVariant<std::tuple<double, double, double, double>>(
        PropertyValueConvertDBus<
            std::tuple<double, double, double, double>,
            std::tuple<double, double, double, double>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<std::tuple<double, double, double, double>>(
        PropertyValueConvertDBus<std::tuple<double, double, double, double>,
                                 std::tuple<double, double, double, double>>::
            toRaw(
                dbusGetVariantValue<std::tuple<double, double, double, double>>(
                    value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("(dddd)"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::Orientation3DType() {
  return vx::types::Orientation3D::type();
}
QSharedPointer<PropertyType> vx::types::Orientation3D::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeOrientation3D>();
  return type;
}

namespace {
class PropertyTypeOutputNodeReference : public PropertyType {
 public:
  PropertyTypeOutputNodeReference()
      : PropertyType(
            "de.uni_stuttgart.Voxie.PropertyType.OutputNodeReference",
            "Output node reference",
            QVariant::fromValue<QDBusObjectPath>(QDBusObjectPath("/"))) {}
  ~PropertyTypeOutputNodeReference() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<QDBusObjectPath>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QDBusObjectPath>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override { return qMetaTypeId<QDBusObjectPath>(); }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new OutputNodeReferenceUI(property, node);
  }

  QList<QString> compatibilityNames() override {
    return {
        "de.uni_stuttgart.Voxie.PropertyType.OutputObjectReference",
    };
  }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<QDBusObjectPath>(
        parseNotSupported<QDBusObjectPath>(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<QDBusObjectPath>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<QDBusObjectPath>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QDBusObjectPath>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<QDBusObjectPath>();
    return dbusMakeVariant<QDBusObjectPath>(
        PropertyValueConvertDBus<QDBusObjectPath, QDBusObjectPath>::fromRaw(
            valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<QDBusObjectPath>(
        PropertyValueConvertDBus<QDBusObjectPath, QDBusObjectPath>::toRaw(
            dbusGetVariantValue<QDBusObjectPath>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("o"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::OutputNodeReferenceType() {
  return vx::types::OutputNodeReference::type();
}
QSharedPointer<PropertyType> vx::types::OutputNodeReference::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeOutputNodeReference>();
  return type;
}

namespace {
class PropertyTypePoint2D : public PropertyType {
 public:
  PropertyTypePoint2D()
      : PropertyType("de.uni_stuttgart.Voxie.PropertyType.Point2D",
                     "Point (2D)",
                     QVariant::fromValue<std::tuple<double, double>>(
                         vx::TupleVector<double, 2>(0, 0))) {}
  ~PropertyTypePoint2D() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<std::tuple<double, double>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<double, double>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<std::tuple<double, double>>();
  }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new Point2DUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<std::tuple<double, double>>(
        ParseJsonFun<std::tuple<double, double>>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<std::tuple<double, double>>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<std::tuple<double, double>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<double, double>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<std::tuple<double, double>>();
    return dbusMakeVariant<std::tuple<double, double>>(
        PropertyValueConvertDBus<
            std::tuple<double, double>,
            std::tuple<double, double>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<std::tuple<double, double>>(
        PropertyValueConvertDBus<std::tuple<double, double>,
                                 std::tuple<double, double>>::
            toRaw(dbusGetVariantValue<std::tuple<double, double>>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("(dd)"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::Point2DType() {
  return vx::types::Point2D::type();
}
QSharedPointer<PropertyType> vx::types::Point2D::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypePoint2D>();
  return type;
}

namespace {
class PropertyTypePosition3D : public PropertyType {
 public:
  PropertyTypePosition3D()
      : PropertyType("de.uni_stuttgart.Voxie.PropertyType.Position3D",
                     "Position",
                     QVariant::fromValue<std::tuple<double, double, double>>(
                         vx::TupleVector<double, 3>(0, 0, 0))) {}
  ~PropertyTypePosition3D() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<std::tuple<double, double, double>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<double, double, double>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<std::tuple<double, double, double>>();
  }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new Position3DUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<std::tuple<double, double, double>>(
        ParseJsonFun<std::tuple<double, double, double>>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<std::tuple<double, double, double>>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<std::tuple<double, double, double>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<double, double, double>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<std::tuple<double, double, double>>();
    return dbusMakeVariant<std::tuple<double, double, double>>(
        PropertyValueConvertDBus<
            std::tuple<double, double, double>,
            std::tuple<double, double, double>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<std::tuple<double, double, double>>(
        PropertyValueConvertDBus<std::tuple<double, double, double>,
                                 std::tuple<double, double, double>>::
            toRaw(dbusGetVariantValue<std::tuple<double, double, double>>(
                value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("(ddd)"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::Position3DType() {
  return vx::types::Position3D::type();
}
QSharedPointer<PropertyType> vx::types::Position3D::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypePosition3D>();
  return type;
}

namespace {
class PropertyTypeSizeInteger3D : public PropertyType {
 public:
  PropertyTypeSizeInteger3D()
      : PropertyType("de.uni_stuttgart.Voxie.PropertyType.SizeInteger3D",
                     "Size (integer)",
                     QVariant::fromValue<std::tuple<quint64, quint64, quint64>>(
                         vx::TupleVector<quint64, 3>(0, 0, 0))) {}
  ~PropertyTypeSizeInteger3D() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() !=
        qMetaTypeId<std::tuple<quint64, quint64, quint64>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<quint64, quint64, quint64>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<std::tuple<quint64, quint64, quint64>>();
  }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new SizeInteger3DUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<std::tuple<quint64, quint64, quint64>>(
        ParseJsonFun<std::tuple<quint64, quint64, quint64>>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<std::tuple<quint64, quint64, quint64>>(value,
                                                                    this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() !=
        qMetaTypeId<std::tuple<quint64, quint64, quint64>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<quint64, quint64, quint64>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<std::tuple<quint64, quint64, quint64>>();
    return dbusMakeVariant<std::tuple<quint64, quint64, quint64>>(
        PropertyValueConvertDBus<
            std::tuple<quint64, quint64, quint64>,
            std::tuple<quint64, quint64, quint64>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<std::tuple<quint64, quint64, quint64>>(
        PropertyValueConvertDBus<std::tuple<quint64, quint64, quint64>,
                                 std::tuple<quint64, quint64, quint64>>::
            toRaw(dbusGetVariantValue<std::tuple<quint64, quint64, quint64>>(
                value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("(ttt)"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::SizeInteger3DType() {
  return vx::types::SizeInteger3D::type();
}
QSharedPointer<PropertyType> vx::types::SizeInteger3D::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeSizeInteger3D>();
  return type;
}

namespace {
class PropertyTypeString : public PropertyType {
 public:
  PropertyTypeString()
      : PropertyType("de.uni_stuttgart.Voxie.PropertyType.String", "String",
                     QVariant::fromValue<QString>("")) {}
  ~PropertyTypeString() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<QString>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QString>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override { return qMetaTypeId<QString>(); }

  bool isComparable() override { return true; }
  int compare(
      /*const QSharedPointer<NodeProperty>& property,*/ const QVariant& v1,
      const QVariant& v2) override {
    if (v1.userType() != qMetaTypeId<QString>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QString>()))
              .arg(QMetaType::typeName(v1.userType()))
              .arg(v1.userType()));
    if (v2.userType() != qMetaTypeId<QString>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QString>()))
              .arg(QMetaType::typeName(v2.userType()))
              .arg(v2.userType()));
    return defaultValueCompare(  // property,
        vx::PropertyValueConvertRaw<QString, QString>::fromRaw(
            v1.value<QString>()),
        vx::PropertyValueConvertRaw<QString, QString>::fromRaw(
            v2.value<QString>()));
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new StringUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<QString>(ParseJsonFun<QString>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<QString>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<QString>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QString>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<QString>();
    return dbusMakeVariant<QString>(
        PropertyValueConvertDBus<QString, QString>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<QString>(
        PropertyValueConvertDBus<QString, QString>::toRaw(
            dbusGetVariantValue<QString>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("s"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::StringType() {
  return vx::types::String::type();
}
QSharedPointer<PropertyType> vx::types::String::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeString>();
  return type;
}

namespace {
class PropertyTypeThresholdLabelMapping : public PropertyType {
 public:
  PropertyTypeThresholdLabelMapping()
      : PropertyType(
            "de.uni_stuttgart.Voxie.PropertyType.ThresholdLabelMapping",
            "ThresholdLabelMapping",
            QVariant::fromValue<QList<std::tuple<
                double, std::tuple<double, double, double, double>, qint64>>>(
                QList<std::tuple<double, vx::TupleVector<double, 4>, qint64>>{
                    std::make_tuple(NAN, vx::TupleVector<double, 4>(0, 0, 0, 0),
                                    0),
                    std::make_tuple(0, vx::TupleVector<double, 4>(0, 0, 0, 1),
                                    0),
                    std::make_tuple(1, vx::TupleVector<double, 4>(1, 1, 1, 1),
                                    0)})) {}
  ~PropertyTypeThresholdLabelMapping() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() !=
        qMetaTypeId<QList<std::tuple<
            double, std::tuple<double, double, double, double>, qint64>>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<QList<std::tuple<
                      double, std::tuple<double, double, double, double>,
                      qint64>>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<QList<std::tuple<
        double, std::tuple<double, double, double, double>, qint64>>>();
  }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new ThresholdLabelMappingUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<QList<std::tuple<
        double, std::tuple<double, double, double, double>, qint64>>>(
        parseNotSupported<QList<std::tuple<
            double, std::tuple<double, double, double, double>, qint64>>>(
            value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<QList<std::tuple<
        double, std::tuple<double, double, double, double>, qint64>>>(value,
                                                                      this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() !=
        qMetaTypeId<QList<std::tuple<
            double, std::tuple<double, double, double, double>, qint64>>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<QList<std::tuple<
                      double, std::tuple<double, double, double, double>,
                      qint64>>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<QList<std::tuple<
        double, std::tuple<double, double, double, double>, qint64>>>();
    return dbusMakeVariant<QList<std::tuple<
        double, std::tuple<double, double, double, double>, qint64>>>(
        PropertyValueConvertDBus<
            QList<std::tuple<double, std::tuple<double, double, double, double>,
                             qint64>>,
            QList<std::tuple<double, std::tuple<double, double, double, double>,
                             qint64>>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<QList<std::tuple<
        double, std::tuple<double, double, double, double>, qint64>>>(
        PropertyValueConvertDBus<
            QList<std::tuple<double, std::tuple<double, double, double, double>,
                             qint64>>,
            QList<std::tuple<double, std::tuple<double, double, double, double>,
                             qint64>>>::
            toRaw(dbusGetVariantValue<QList<std::tuple<
                      double, std::tuple<double, double, double, double>,
                      qint64>>>(value)));
  }

  QDBusSignature dbusSignature() override {
    return QDBusSignature("a(d(dddd)x)");
  }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::ThresholdLabelMappingType() {
  return vx::types::ThresholdLabelMapping::type();
}
QSharedPointer<PropertyType> vx::types::ThresholdLabelMapping::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeThresholdLabelMapping>();
  return type;
}

namespace {
class PropertyTypeTomographyRawDataImageKind : public PropertyType {
 public:
  PropertyTypeTomographyRawDataImageKind()
      : PropertyType(
            "de.uni_stuttgart.Voxie.PropertyType.TomographyRawDataImageKind",
            "Tomography raw data image kind",
            QVariant::fromValue<QJsonObject>(QJsonObject{})) {}
  ~PropertyTypeTomographyRawDataImageKind() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<QJsonObject>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QJsonObject>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override { return qMetaTypeId<QJsonObject>(); }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new TomographyRawDataImageKindUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<QJsonObject>(
        ParseJsonFun<QJsonObject>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<QJsonObject>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<QJsonObject>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(qMetaTypeId<QJsonObject>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<QJsonObject>();
    return dbusMakeVariant<QMap<QString, QDBusVariant>>(
        PropertyValueConvertDBus<
            QJsonObject, QMap<QString, QDBusVariant>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<QJsonObject>(
        PropertyValueConvertDBus<QJsonObject, QMap<QString, QDBusVariant>>::
            toRaw(dbusGetVariantValue<QMap<QString, QDBusVariant>>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("a{sv}"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::TomographyRawDataImageKindType() {
  return vx::types::TomographyRawDataImageKind::type();
}
QSharedPointer<PropertyType> vx::types::TomographyRawDataImageKind::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeTomographyRawDataImageKind>();
  return type;
}

namespace {
class PropertyTypeTomographyRawDataImageList : public PropertyType {
 public:
  PropertyTypeTomographyRawDataImageList()
      : PropertyType(
            "de.uni_stuttgart.Voxie.PropertyType.TomographyRawDataImageList",
            "Tomography raw data image list",
            QVariant::fromValue<std::tuple<QString, QJsonObject>>(
                std::make_tuple("", QJsonObject{}))) {}
  ~PropertyTypeTomographyRawDataImageList() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() != qMetaTypeId<std::tuple<QString, QJsonObject>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<QString, QJsonObject>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<std::tuple<QString, QJsonObject>>();
  }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new TomographyRawDataImageListUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<std::tuple<QString, QJsonObject>>(
        ParseJsonFun<std::tuple<QString, QJsonObject>>::parse(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<std::tuple<QString, QJsonObject>>(value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() != qMetaTypeId<std::tuple<QString, QJsonObject>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<std::tuple<QString, QJsonObject>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<std::tuple<QString, QJsonObject>>();
    return dbusMakeVariant<std::tuple<QString, QMap<QString, QDBusVariant>>>(
        PropertyValueConvertDBus<
            std::tuple<QString, QJsonObject>,
            std::tuple<QString,
                       QMap<QString, QDBusVariant>>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<std::tuple<QString, QJsonObject>>(
        PropertyValueConvertDBus<
            std::tuple<QString, QJsonObject>,
            std::tuple<QString, QMap<QString, QDBusVariant>>>::
            toRaw(dbusGetVariantValue<
                  std::tuple<QString, QMap<QString, QDBusVariant>>>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("(sa{sv})"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::TomographyRawDataImageListType() {
  return vx::types::TomographyRawDataImageList::type();
}
QSharedPointer<PropertyType> vx::types::TomographyRawDataImageList::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeTomographyRawDataImageList>();
  return type;
}

namespace {
class PropertyTypeValueColorMapping : public PropertyType {
 public:
  PropertyTypeValueColorMapping()
      : PropertyType(
            "de.uni_stuttgart.Voxie.PropertyType.ValueColorMapping",
            "Color mapping",
            QVariant::fromValue<QList<std::tuple<
                double, std::tuple<double, double, double, double>, qint32>>>(
                QList<std::tuple<double, vx::TupleVector<double, 4>, qint32>>{
                    std::make_tuple(NAN, vx::TupleVector<double, 4>(0, 0, 0, 0),
                                    0),
                    std::make_tuple(0, vx::TupleVector<double, 4>(0, 0, 0, 1),
                                    0),
                    std::make_tuple(1, vx::TupleVector<double, 4>(1, 1, 1, 1),
                                    0)})) {}
  ~PropertyTypeValueColorMapping() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() !=
        qMetaTypeId<QList<std::tuple<
            double, std::tuple<double, double, double, double>, qint32>>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<QList<std::tuple<
                      double, std::tuple<double, double, double, double>,
                      qint32>>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    verifyValueColorMapping(
        property,
        value.value<QList<std::tuple<
            double, std::tuple<double, double, double, double>, qint32>>>());
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<QList<std::tuple<
        double, std::tuple<double, double, double, double>, qint32>>>();
  }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new ValueColorMappingUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<QList<std::tuple<
        double, std::tuple<double, double, double, double>, qint32>>>(
        parseNotSupported<QList<std::tuple<
            double, std::tuple<double, double, double, double>, qint32>>>(
            value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<QList<std::tuple<
        double, std::tuple<double, double, double, double>, qint32>>>(value,
                                                                      this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() !=
        qMetaTypeId<QList<std::tuple<
            double, std::tuple<double, double, double, double>, qint32>>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<QList<std::tuple<
                      double, std::tuple<double, double, double, double>,
                      qint32>>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<QList<std::tuple<
        double, std::tuple<double, double, double, double>, qint32>>>();
    return dbusMakeVariant<QList<std::tuple<
        double, std::tuple<double, double, double, double>, qint32>>>(
        PropertyValueConvertDBus<
            QList<std::tuple<double, std::tuple<double, double, double, double>,
                             qint32>>,
            QList<std::tuple<double, std::tuple<double, double, double, double>,
                             qint32>>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<QList<std::tuple<
        double, std::tuple<double, double, double, double>, qint32>>>(
        PropertyValueConvertDBus<
            QList<std::tuple<double, std::tuple<double, double, double, double>,
                             qint32>>,
            QList<std::tuple<double, std::tuple<double, double, double, double>,
                             qint32>>>::
            toRaw(dbusGetVariantValue<QList<std::tuple<
                      double, std::tuple<double, double, double, double>,
                      qint32>>>(value)));
  }

  QDBusSignature dbusSignature() override {
    return QDBusSignature("a(d(dddd)i)");
  }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::ValueColorMappingType() {
  return vx::types::ValueColorMapping::type();
}
QSharedPointer<PropertyType> vx::types::ValueColorMapping::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeValueColorMapping>();
  return type;
}

namespace {
class PropertyTypeVolumeIndexList : public PropertyType {
 public:
  PropertyTypeVolumeIndexList()
      : PropertyType(
            "de.uni_stuttgart.Voxie.PropertyType.VolumeIndexList",
            "Volume index list",
            QVariant::fromValue<QList<std::tuple<quint32, quint32, quint32>>>(
                QList<std::tuple<quint32, quint32, quint32>>())) {}
  ~PropertyTypeVolumeIndexList() {}

  void verifyValue(NodeProperty& property, const QVariant& value) override {
    Q_UNUSED(property);
    if (value.userType() !=
        qMetaTypeId<QList<std::tuple<quint32, quint32, quint32>>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<QList<std::tuple<quint32, quint32, quint32>>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
  }
  QVariant canonicalize(NodeProperty& property,
                        const QVariant& value) override {
    verifyValue(property, value);
    return value;
  }
  int getRawQMetaType() override {
    return qMetaTypeId<QList<std::tuple<quint32, quint32, quint32>>>();
  }

  bool isComparable() override { return false; }
  int compare(/*const QSharedPointer<NodeProperty>&,*/ const QVariant&,
              const QVariant&) override {
    throw vx::Exception("de.uni_stuttgart.Voxie.InvalidOperation",
                        "Comparison operator not implemented");
  }

  PropertyUI* createUI(const QSharedPointer<NodeProperty>& property,
                       Node* node) override {
    return new VolumeIndexListUI(property, node);
  }

  QList<QString> compatibilityNames() override { return {}; }
  QVariant parseJson(const QJsonValue& value) override {
    return QVariant::fromValue<QList<std::tuple<quint32, quint32, quint32>>>(
        parseNotSupported<QList<std::tuple<quint32, quint32, quint32>>>(value));
  }
  QString valueToString(const QVariant& value) override {
    return vx::valueToString<QList<std::tuple<quint32, quint32, quint32>>>(
        value, this);
  }
  QDBusVariant rawToDBus(const QVariant& value) override {
    if (value.userType() !=
        qMetaTypeId<QList<std::tuple<quint32, quint32, quint32>>>())
      throw Exception(
          "de.uni_stuttgart.Voxie.InvalidPropertyValue",
          QString(
              "Property value has unexpected type, expected %1, got %2 (%3)")
              .arg(QMetaType::typeName(
                  qMetaTypeId<QList<std::tuple<quint32, quint32, quint32>>>()))
              .arg(QMetaType::typeName(value.userType()))
              .arg(value.userType()));
    auto valueRaw = value.value<QList<std::tuple<quint32, quint32, quint32>>>();
    return dbusMakeVariant<QList<std::tuple<quint32, quint32, quint32>>>(
        PropertyValueConvertDBus<
            QList<std::tuple<quint32, quint32, quint32>>,
            QList<std::tuple<quint32, quint32, quint32>>>::fromRaw(valueRaw));
  }
  QVariant dbusToRaw(const QDBusVariant& value) override {
    return QVariant::fromValue<QList<std::tuple<quint32, quint32, quint32>>>(
        PropertyValueConvertDBus<QList<std::tuple<quint32, quint32, quint32>>,
                                 QList<std::tuple<quint32, quint32, quint32>>>::
            toRaw(dbusGetVariantValue<
                  QList<std::tuple<quint32, quint32, quint32>>>(value)));
  }

  QDBusSignature dbusSignature() override { return QDBusSignature("a(uuu)"); }
};
}  // namespace
QSharedPointer<PropertyType> vx::types::VolumeIndexListType() {
  return vx::types::VolumeIndexList::type();
}
QSharedPointer<PropertyType> vx::types::VolumeIndexList::type() {
  static QSharedPointer<PropertyType> type =
      makeSharedQObject<PropertyTypeVolumeIndexList>();
  return type;
}

#define LIST_ALL_TYPES                                                        \
  vx::types::Boolean::type(), vx::types::Box3DAxisAligned::type(),            \
      vx::types::Color::type(), vx::types::DataType::type(),                  \
      vx::types::Enumeration::type(), vx::types::FileName::type(),            \
      vx::types::Float::type(), vx::types::GeometricPrimitive::type(),        \
      vx::types::Int::type(), vx::types::IntList::type(),                     \
      vx::types::LabelList::type(), vx::types::ListPosition3D::type(),        \
      vx::types::ListPosition3DDoubleTuple::type(),                           \
      vx::types::NodeReference::type(), vx::types::NodeReferenceList::type(), \
      vx::types::Orientation3D::type(),                                       \
      vx::types::OutputNodeReference::type(), vx::types::Point2D::type(),     \
      vx::types::Position3D::type(), vx::types::SizeInteger3D::type(),        \
      vx::types::String::type(), vx::types::ThresholdLabelMapping::type(),    \
      vx::types::TomographyRawDataImageKind::type(),                          \
      vx::types::TomographyRawDataImageList::type(),                          \
      vx::types::ValueColorMapping::type(),                                   \
      vx::types::VolumeIndexList::type(),
